<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Interval (interval_base.Interval)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">interval_base</a> &#x00BB; Interval</nav><h1>Module <code>Interval</code></h1><p>Base module for interval arithmetic.</p><dl><dt>version</dt><dd>1.5</dd></dl><nav class="toc"><ul><li><a href="#intervals-with-float-endpoints">Intervals with float endpoints</a></li><li><a href="#directed-rounding">Directed rounding</a></li><li><a href="#changing-the-rounding-mode-(dangerous)">Changing the rounding mode (DANGEROUS)</a></li></ul></nav></header><dl><dt class="spec module-type" id="module-type-T"><a href="#module-type-T" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-T/index.html">T</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Basic signature for interval arithmetic packages.</p></dd></dl><section><header><h3 id="intervals-with-float-endpoints"><a href="#intervals-with-float-endpoints" class="anchor"></a>Intervals with float endpoints</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.low" class="anchored"><td class="def field"><a href="#type-t.low" class="anchor"></a><code>low : float;</code></td><td class="doc"><p>lower bound, possibly = -∞</p></td></tr><tr id="type-t.high" class="anchored"><td class="def field"><a href="#type-t.high" class="anchor"></a><code>high : float;</code></td><td class="doc"><p>higher bound, possibly = +∞</p></td></tr></table><code>}</code></dt><dd><p>The interval type. Be careful however when creating intervals. For example, the following code: <code>let a = {low=1./.3.; high=1./.3.}</code> creates an interval which does NOT contain the mathematical object 1/3.</p><p>If you want to create an interval representing 1/3, you have to write <code>let a = I.(inv(v 3. 3.))</code> because rounding will then be properly handled by <a href="I/index.html#val-inv"><code>I.inv</code></a> and the resulting interval will indeed contain the exact value of 1/3.</p></dd></dl><dl><dt class="spec exception" id="exception-Division_by_zero"><a href="#exception-Division_by_zero" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Division_by_zero</span></code></dt><dd><p>Exception raised when a division by 0 occurs.</p></dd></dl><dl><dt class="spec exception" id="exception-Domain_error"><a href="#exception-Domain_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Domain_error</span> <span class="keyword">of</span> string</code></dt><dd><p>Exception raised when an interval is completely outside the domain of a function. The string is the name of the function and is meant to help when running code in the REPL (aka toploop).</p></dd></dl><dl><dt class="spec module" id="module-I"><a href="#module-I" class="anchor"></a><code><span class="keyword">module</span> <a href="I/index.html">I</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interval operations. Locally open this module — using e.g. <code>I.(...)</code> — to redefine classical arithmetic operators for interval arithmetic.</p></dd></dl></section><section><header><h3 id="directed-rounding"><a href="#directed-rounding" class="anchor"></a>Directed rounding</h3></header><dl><dt class="spec module-type" id="module-type-DIRECTED"><a href="#module-type-DIRECTED" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-DIRECTED/index.html">DIRECTED</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Interface for up and down roundings.</p></dd></dl><dl><dt class="spec module" id="module-Low"><a href="#module-Low" class="anchor"></a><code><span class="keyword">module</span> <a href="Low/index.html">Low</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Functions rounding down their results.</p></dd></dl><dl><dt class="spec module" id="module-High"><a href="#module-High" class="anchor"></a><code><span class="keyword">module</span> <a href="High/index.html">High</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Functions rounding up their results.</p></dd></dl></section><section><header><h3 id="changing-the-rounding-mode-(dangerous)"><a href="#changing-the-rounding-mode-(dangerous)" class="anchor"></a>Changing the rounding mode (DANGEROUS)</h3></header><aside><p>Below, we have functions for changing the rounding mode. The default mode for rounding is NEAREST.</p><p>BE VERY CAREFUL: using these functions unwisely can ruin all your computations. Remember also that on 64 bits machine these functions won't change the behaviour of the SSE instructions.</p><p>When setting the rounding mode to UPWARD or DOWNWARD, it is better to set it immediately back to NEAREST. However we have no guarantee on how the compiler will reorder the instructions generated. It is ALWAYS better to write:</p><pre><code class="ml">let a = set_high(); let res = 1./.3. in
set_nearest (); res;; </code></pre><p>The above code will NOT work on linux-x64 where many floating point functions are implemented using SSE instructions. These three functions should only be used when there is no other solution, and you really know what tou are doing, and this should never happen. Please use the regular functions of the fpu module for computations. For example prefer:</p><pre><code class="ml">let a = High.(1. /. 3.)  </code></pre><p>PS: The Interval module and the fpu module functions correctly set and restore the rounding mode for all interval computations, so you don't really need these functions.</p><p>PPS: Please, don't use them...</p></aside><dl><dt class="spec value" id="val-set_low"><a href="#val-set_low" class="anchor"></a><code><span class="keyword">val</span> set_low : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the rounding mod to DOWNWARD (towards minus infinity)</p></dd></dl><dl><dt class="spec value" id="val-set_high"><a href="#val-set_high" class="anchor"></a><code><span class="keyword">val</span> set_high : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the rounding mod to UPWARD (towards infinity)</p></dd></dl><dl><dt class="spec value" id="val-set_nearest"><a href="#val-set_nearest" class="anchor"></a><code><span class="keyword">val</span> set_nearest : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Sets the rounding mod to NEAREST (default mode)</p></dd></dl></section></div></body></html>